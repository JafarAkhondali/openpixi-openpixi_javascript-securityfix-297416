<!DOCTYPE html>
<html>

<script type = "text/javascript" src="threejs/build/three.min.js"></script>
<script type = "text/javascript" src="scripts/OrbitControls.js"></script>
<script type="text/javascript" src="scripts/Detector.js"></script>

<script type = "text/javascript" src="scripts/stats.js/build/stats.min.js"></script>
<script type="text/javascript" src="scripts/dat.gui.min.js"></script>

<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="simulator.js"></script>


<head>
    <title>Openpixi</title>
</head>
<body>
<!--begin shaders-->

<!-- pass through shaders -->
<script id="passThruVertexShader" type="x-shader/x-vertex">

			void main()	{

				gl_Position = vec4( position, 1.0 );

			}

		</script>

<script id="passThruFragmentShader" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;

				vec3 color = texture2D( texture, uv ).xyz;

				gl_FragColor=vec4(color, 1.0);

			}

		</script>
<!-- end pass through shaders -->

<!--particle acceleration, position and velocity shaders -->
<script id="fragmentShaderPosition" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D texturePosition;

            const float UPPER_BOUNDS = 200.0;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			void main()	{


				vec2 uv = gl_FragCoord.xy / resolution.xy;

				vec3 position = texture2D( texturePosition, uv ).xyz;

				vec3 velocity = texture2D( textureVelocity, uv ).xyz;

				//periodic boundary box:
				if ((position.x + velocity.x ) < LOWER_BOUNDS) position.x += UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) < LOWER_BOUNDS) position.y += UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) < LOWER_BOUNDS) position.z += UPPER_BOUNDS*2.0;

				if ((position.x + velocity.x ) > UPPER_BOUNDS) position.x -= UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) > UPPER_BOUNDS) position.y -= UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) > UPPER_BOUNDS) position.z -= UPPER_BOUNDS*2.0;

				gl_FragColor=vec4(position + velocity*dt , 1.0);

			}

		</script>


<script id="fragmentShaderVelocity" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D texturePosition;
			uniform sampler2D textureAcceleration;

			const float UPPER_BOUNDS = 200.0;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			const float bouncy = 1.0;


			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;



				vec3 oldPosition = texture2D( texturePosition, uv ).xyz;
				vec3 oldVelocity = texture2D( textureVelocity, uv ).xyz;
				vec3 acceleration = texture2D( textureAcceleration, uv).xyz;


				vec3 velocity=oldVelocity+acceleration*dt;

                //bounding box
                //wall
                // if ((oldPosition.x + velocity.x ) < LOWER_BOUNDS) velocity.x = -velocity.x*bouncy;
				//if ((oldPosition.y + velocity.y ) < LOWER_BOUNDS) velocity.y = -velocity.y*bouncy;
				//if ((oldPosition.z + velocity.z ) < LOWER_BOUNDS) velocity.z = -velocity.z*bouncy;

				//if ((oldPosition.x + velocity.x ) > UPPER_BOUNDS) velocity.x = -velocity.x*bouncy;
				//if ((oldPosition.y + velocity.y ) > UPPER_BOUNDS) velocity.y = -velocity.y*bouncy;
				//if ((oldPosition.z + velocity.z ) > UPPER_BOUNDS) velocity.z = -velocity.z*bouncy;

                //periodic
                //do not change velocity


				gl_FragColor=vec4(velocity, 1.0);

			}

		</script>

<script id="fragmentShaderAcceleration" type="x-shader/x-fragment">



            uniform vec2 resolution;
            uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D textureMQ;
            float gy;

            uniform float size;

            uniform sampler2D textureFieldB;
            uniform sampler2D textureFieldE;
            uniform sampler2D texturePosition;

            uniform sampler2D textureField;

            const float drag = 0.0005;

            vec2 getFieldPoint(vec3 pos){


                float maxval = 400.0;


                //map particles position  to [0,size]
                float x = ((pos.x+maxval/2.0)/maxval)*(size);
                float y = ((pos.y+maxval/2.0)/maxval)*(size);
                float z = ((pos.z+maxval/2.0)/maxval)*(size);

                //now round to nearest fp
                float lx = floor(x);
                float ly = floor(y);
                float lz = floor(z);


                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);


                float qu = col*(size)+lx;
                float qv = row*(size)+ly;

               // if(qv==0.0){ //works ok
               // return vec2(0.0,0.0);
               // }
               // else{
               // return vec2(1.0,1.0);
               // }

                qu = (qu+0.5)/(size*width);
                qv = (qv+0.5)/(size*width);


                return vec2(qu,qv);


            }

            void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;


                vec3 pos = texture2D(texturePosition,uv).xyz;

                vec2 quv = getFieldPoint(pos);


                vec3 B = texture2D(textureFieldB,quv).xyz;
                vec3 E = texture2D(textureFieldE,quv).xyz;

                float q = texture2D(textureMQ,uv).y;
                float m = texture2D(textureMQ,uv).x;

                vec3 v = texture2D(textureVelocity,uv).xyz;
                vec3 acceleration =  -drag * v + m*gy + (q/m*(E+cross(v,B)));


				gl_FragColor=vec4(acceleration,1.0);


				}



</script>

<script id="fragmentShaderFieldE" type="x-shader/x-fragment">
           uniform sampler2D textureFieldE;
           uniform sampler2D textureFieldB;
           uniform sampler2D textureFieldJ;
           uniform float dt;
           uniform float size;
           uniform vec2 resolution;


            float width = ceil(sqrt(size));

            vec4 getSteps(vec2 uv,float h){

            //calculate new uv vector if x changes by +h

            float x = uv.x*(size*width);
            float col = ceil(uv.x*(width))-1.0;
            if(uv.x==0.0){
                col=0.0;
            }

            if(x>size-1.0){
            x -= col*size;
            x = mod((x+h),size);
            x += col*size;
            }else{
            x = mod((x+h),size);
            }

            x = x/(size*width);


            //calculate new uv vector if y changes by +h

            float y = uv.y*(size*width);
            float row = ceil(uv.y*(width))-1.0;

            if(uv.y==0.0){
                row=0.0;
            }
            if(x>size-1.0){
            y -= row*size;
            y = mod((y+h),size);
            y += row*size;
            }else{
            y = mod((y+1.0),size);
            }

            y = y/(size*width);


            //calculate new uv vector if z changes by +h

            vec2 zuv=uv;
            float posz = col+row*width;
            posz=mod((posz+h),size);//tile number + h

            float tx = uv.x*(size*width);
            float ty = uv.y*(size*width);

            //per tile coordinate

            float localx = tx - col*size;
            if(tx<size){
            localx =tx;
            }
            float localy = ty - row*size;
            if(ty<size){
            localy =ty;
            }

            //new col and row
            col = mod(posz,width);
            row = floor(posz/width);


            if(tx<size){
            zuv.x = localx/(size*width);
            }else{
            zuv.x =  (localx + col*size)/(size*width);
            }
            if(ty<size){
            zuv.y = localy/(size*width);
            }else{
            zuv.y = (localy + row*size)/(size*width);
            }

            return vec4(x,y,zuv);

            }


           vec3 rotor(vec2 uv){

            float h = 1.0;

            vec4 vecuv = getSteps(uv,h);

            vec3 bold = texture2D(textureFieldB,uv).xyz;
            vec3 dx = texture2D(textureFieldB, vec2(vecuv.x,uv.y)).xyz;
            vec3 dy = texture2D(textureFieldB, vec2(uv.x,vecuv.y)).xyz;
            vec3 dz = texture2D(textureFieldB,vec2(vecuv.z,vecuv.w)).xyz;

            float rxl = (dy.z-bold.z)/h;
            float rxr = (dz.y-bold.y)/h;

            float ryl = (dz.x-bold.x)/h;
            float ryr = (dx.z-bold.z)/h;

            float rzl = (dx.y-bold.y)/h;
            float rzr = (dy.x-bold.x)/h;


            float rx = rxl-rxr;
            float ry = ryl-ryr;
            float rz = rzl-rzr;

            return vec3(rx,ry,rz);
            }


           void main(){

            vec2 uv = gl_FragCoord.xy/resolution.xy;


            vec3 rotB = rotor(uv);
            vec3 j = texture2D(textureFieldJ,uv).xyz;
            vec3 E_old = texture2D(textureFieldE,uv).xyz;
            vec3 E_new = E_old + dt*(rotB-j);

            gl_FragColor=vec4(E_old, 1.0);




           }
</script>

<script id="fragmentShaderFieldB" type="x-shader/x-fragment">

           uniform sampler2D textureFieldE;
           uniform sampler2D textureFieldB;
           uniform float dt;
           uniform float size;
           uniform vec2 resolution;




            float width = ceil(sqrt(size));


           vec4 getSteps(vec2 uv,float h){

            //calculate new uv vector if x changes by +h

            float x = uv.x*(size*width);
            float col = ceil(uv.x*(width))-1.0;
            if(uv.x==0.0){
                col=0.0;
            }

            if(x>size-1.0){
            x -= col*size;
            x = mod((x+h),size);
            x += col*size;
            }else{
            x = mod((x+h),size);
            }

            x = x/(size*width);


            //calculate new uv vector if y changes by +h

            float y = uv.y*(size*width);
            float row = ceil(uv.y*(width))-1.0;

            if(uv.y==0.0){
                row=0.0;
            }
            if(x>size-1.0){
            y -= row*size;
            y = mod((y+h),size);
            y += row*size;
            }else{
            y = mod((y+h),size);
            }

            y = y/(size*width);


            //calculate new uv vector if z changes by +h

            vec2 zuv=uv;
            float posz = col+row*width;
            posz=mod((posz+h),size);//tile number + h

            float tx = uv.x*(size*width-1.0);
            float ty = uv.y*(size*width-1.0);

            //per tile coordinate

            float localx = tx - col*size;
            if(tx<size){
            localx =tx;
            }
            float localy = ty - row*size;
            if(ty<size){
            localy =ty;
            }

            //new col and row
            col = mod(posz,width);
            row = floor(posz/width);


            if(tx<size){
            zuv.x = localx/(size*width);
            }else{
            zuv.x =  (localx + col*size)/(size*width);
            }
            if(ty<size){
            zuv.y = localy/(size*width);
            }else{
            zuv.y = (localy + row*size)/(size*width);
            }

            return vec4(x,y,zuv);

            }

            vec3 rotor(vec2 uv){

            float h =1.0;
            vec4 vecuv = getSteps(uv,h);


            vec3 eold = texture2D(textureFieldE,uv).xyz;
            vec3 dx = texture2D(textureFieldE, vec2(vecuv.x,uv.y)).xyz;
            vec3 dy = texture2D(textureFieldE, vec2(uv.x,vecuv.y)).xyz;
            vec3 dz = texture2D(textureFieldE, vec2(vecuv.z,vecuv.w)).xyz;

            float rxl = (dy.z-eold.z)/h;
            float rxr = (dz.y-eold.y)/h;

            float ryl = (dz.x-eold.x)/h;
            float ryr = (dx.z-eold.z)/h;

            float rzl = (dx.y-eold.y)/h;
            float rzr = (dy.x-eold.x)/h;



            float rx = rxl-rxr;
            float ry = ryl-ryr;
            float rz = rzl-rzr;

            return vec3(rx,ry,rz);

          }


           void main(){

            vec2 uv = gl_FragCoord.xy/resolution.xy;

            vec3 rotE = rotor(uv);
            vec3 B_old = texture2D(textureFieldB,uv).xyz;
            vec3 B_new = B_old - dt*rotE;

            gl_FragColor=vec4(B_old, 1.0);


           }

</script>

<script id="fragmentShaderJ" type="x-shader/x-fragment">


    uniform vec2 resolution;
    uniform float size;

    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    uniform sampler2D textureJ;

    vec2 getFieldPoint(vec3 pos){




                //look up closest field point
                //linear map z from coordrange to [0,arraysize-1]
                float maxval = 400.0;


                //map particles position  to [0,size-1]
                float x = ((pos.x+maxval/2.0)/maxval)*(size-1.0);
                float y = ((pos.y+maxval/2.0)/maxval)*(size-1.0);
                float z = ((pos.z+maxval/2.0)/maxval)*(size-1.0);

                //now round to nearest fp
                float lx = floor(0.5+x);
                float ly = floor(0.5+y);
                float lz = floor(0.5+z);

                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);

                float qu = col*size+lx;
                float qv = row*size+ly;


                vec2 quv = vec2(qu,qv)/resolution.xy;//the respective texel of the field point
                return quv;


    }

    void main(){
        float LOWER_BOUNDS = -200.0;
        float UPPER_BOUNDS = 200.0;
        vec2 uv = gl_FragCoord.xy/resolution.xy;
        vec3 j = texture2D(textureJ,uv).xyz;

        for(int x = 0; x<100;x++){

            for(int y = 0; y<100;y++){

                vec2 look = vec2(x/100,y/100);
                vec3 position = texture2D(texturePosition,look).xyz;
                vec3 velocity = texture2D(textureVelocity,look).xyz;

                vec2 fp1 = getFieldPoint(position);

                if ((position.x + velocity.x ) < LOWER_BOUNDS) position.x += UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) < LOWER_BOUNDS) position.y += UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) < LOWER_BOUNDS) position.z += UPPER_BOUNDS*2.0;

				if ((position.x + velocity.x ) > UPPER_BOUNDS) position.x -= UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) > UPPER_BOUNDS) position.y -= UPPER_BOUNDS*2.0;
		    	if ((position.z + velocity.z ) > UPPER_BOUNDS) position.z -= UPPER_BOUNDS*2.0;


                vec2 fp2 = getFieldPoint(position+velocity);



                if(abs(fp1.x-uv.x)<0.1&&abs(fp1.y-uv.y)<0.1){ //particle belongs to current field point//fixme
                    j=vec3(0.0,0.0,0.0);
                    if(fp2.x==fp1.x&&fp2.y==fp1.y){
                       //j+=velocity;

                    }else {//particle will leave current field point
                       //j-=velocity;

                    }


                }


            }

        }





        gl_FragColor=vec4(j,1.0);


    }


</script>

<!-- end  position and velocity shaders -->

<!--particle shaders-->

<script id="particleVertexShader" type="x-shader/x-fragment">

     uniform sampler2D lookup;
     uniform float size;
     uniform float scale;

        void main() {

            vec2 lookupuv = position.xy ;
            vec3 pos = texture2D( lookup, lookupuv ).rgb;
            vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
            gl_PointSize  = 1.5;
            gl_Position = projectionMatrix * mvPosition;

}

</script>


<script id="particleFragmentShader" type="x-shader/x-fragment">

                uniform vec3 psColor;
                uniform float opacity;
                void main() {



                gl_FragColor = vec4( 1.0,1.0,1.0, opacity );
                }
</script>

<!--end particle shaders-->

<!--begin E,B vector shaders-->

<script id="vectorVertexShaderE" type="x-shader/x-vertex">
//FIXME: coordinates need not be rounded in this case
uniform sampler2D textureFieldE;
uniform float size;
uniform float width;
uniform float test;

vec2 getUV(vec3 pos){

                //look up closest field point
                //linear map z from coordrange to [0,arraysize-1]
                float maxval = 400.0;
                float test = pos.x;
                //map particles position  to [0,size-1]
                float x = ((pos.x+maxval/2.0)/maxval)*(size-1.0);
                float y = ((pos.y+maxval/2.0)/maxval)*(size-1.0);
                float z = ((pos.z+maxval/2.0)/maxval)*(size-1.0);

                //now round to nearest fp
                float lx = floor(x+0.5);
                float ly = floor(y+0.5);
                float lz = floor(z+0.5);

                float width = ceil(sqrt(size));

                float col = floor(lz/width);
                float row = mod(lz,width);

                float qu = row * size+lx;
                float qv = col*size+ly;

                vec2 quv = vec2(qu,qv)/vec2(size*width-1.0,size*width-1.0);

                return quv;

}

void main() {


vec4 mvPosition;

    mvPosition = modelViewMatrix * vec4( position, 1.0 );


    if(position.y>200.0){
        vec2 uv = getUV(vec3(position.x,position.y-1000.0,position.z));
        vec3 E = texture2D(textureFieldE,uv).xyz;
        vec3 pos = vec3(position.x,position.y-1000.0,position.z);
        pos = pos +E*200.0;//200 is visibility factor
        mvPosition = modelViewMatrix * vec4(pos,1.0);
    }

    gl_Position = projectionMatrix * mvPosition;



}

</script>

<script id="vectorVertexShaderB" type="x-shader/x-vertex">

uniform sampler2D textureFieldB;
uniform float size;
uniform float width;


vec2 getUV(vec3 pos){

                //look up closest field point
                //linear map z from coordrange to [0,arraysize-1]
                float maxval = 400.0;
                float test = pos.x;
                //map particles position  to [0,size-1]
                float x = ((pos.x+maxval/2.0)/maxval)*(size-1.0);
                float y = ((pos.y+maxval/2.0)/maxval)*(size-1.0);
                float z = ((pos.z+maxval/2.0)/maxval)*(size-1.0);

                //now round to nearest fp
                float lx = floor(x+0.5);
                float ly = floor(y+0.5);
                float lz = floor(z+0.5);

                float width = ceil(sqrt(size));

                float col = floor(lz/width);
                float row = mod(lz,width);

                float qu = row * size+lx;
                float qv = col*size+ly;

                vec2 quv = vec2(qu,qv)/vec2(size*width-1.0,size*width-1.0);

                return quv;

}

void main() {


vec4 mvPosition;

    mvPosition = modelViewMatrix * vec4( position, 1.0 );


    if(position.y>200.0){
        vec2 uv = getUV(vec3(position.x,position.y-1000.0,position.z));
        vec3 B = texture2D(textureFieldB,uv).xyz;
        vec3 pos = vec3(position.x,position.y-1000.0,position.z);
        pos = pos +B*200.0;//200 is visibility factor
        mvPosition = modelViewMatrix * vec4(pos,1.0);
    }

    gl_Position = projectionMatrix * mvPosition;



}

</script>

<script id="vectorFragmentShaderE" type="x-shader/x-fragment">

vec3 vColor = vec3(1.0,0.0,1.0);



void main() {

gl_FragColor =  vec4( vColor, 1.0 );


}
</script>

<script id="vectorFragmentShaderB" type="x-shader/x-fragment">

vec3 vColor = vec3(1.0,1.0,0.0);



void main() {

gl_FragColor =  vec4( vColor, 1.0 );


}
</script>
<!--end E,B vector shaders-->

<!--end shaders-->

<!-- global variables -->

<script type="text/javascript">

    //check if WebGL is supported
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();


    //texture debug
    var cameraTex, sceneTex;
    var dispTex = false;
    sceneTex = new THREE.Scene();
    cameraTex = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );

    //global variables
    var WIDTH = 100; // sqrt(number of particles)
    var BOUNDS = 400; //Particle coordinates range from -bounds/2 to bounds/2
    var DT = 1; //delta time
    var FSIZE;
    var B;
    var E;

    var FXY,FZ;

    var container, camera, scene, renderer; //main scene

    var particles, material, geometry; //the particle system

    var uniforms; //uniforms for the particle system's shader

    var simul; //the simulator updates the particles' positions


    //three.js
    container = document.createElement( 'div' );
    document.body.appendChild( container );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 150000 );
    camera.position.z = 400;

    //controls
    var controls = new THREE.OrbitControls( camera, renderer.domElement ); //FIXME: belongs into index


    //gui
    var text;

    var guitext = function(){
        this.gy = 0.0;
        this.Particles = 10000;
        this.dt = 0.8;
        this.fieldpoints =5;

        this.Bx = 0.0;
        this.By = 0.0;
        this.Bz = 0.0;

        this.Ex = 0.0;
        this.Ey = 0.0;
        this.Ez = 0.0;

        this.m = 0.000;
        this.q = 0.0;


    }


    text = new guitext();
    var gui = new dat.GUI({autoPlace: true});
    var f1 = gui.addFolder('B');
    var f2 = gui.addFolder('E');



    gui.add(text, 'Particles',1,10000);
    gui.add(text,'dt',0.0,10.0);
    gui.add(text,'fieldpoints',2,20).step(1);
    gui.add(text, 'gy',-0.9999,0.9999);

    gui.add(text,'m',0.0,1.0);
    gui.add(text,'q',-1.0,1.0);

    f1.add(text,'Bx',-0.1,0.1);
    f1.add(text,'By',-0.1,0.1);
    f1.add(text,'Bz',-0.1,0.1);

    f2.add(text,'Ex',-0.1,0.1);
    f2.add(text,'Ey',-0.1,0.1);
    f2.add(text,'Ez',-0.1,0.1);




    var obj = {reset: function(){init()}};
    gui.add(obj,'reset');

    var inf = {info: function(){//FIXME
        alert('left-click to move camera, \nhold mousewheel to zoom,\n click reset to apply changes')}};

    gui.add(inf,'info');

    var debug= {debug: function(){
        dispTex = !dispTex;
    }}
    gui.add(debug,'debug');


    //end gui

    //stats

    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    document.body.appendChild( stats.domElement );

    //end stats



    //start simulation

    init();




</script>

</body>

</html>