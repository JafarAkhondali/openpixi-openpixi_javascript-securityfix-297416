<!DOCTYPE html>
<html>

<script type = "text/javascript" src="threejs/build/three.min.js"></script>
<script type = "text/javascript" src="scripts/OrbitControls.js"></script>
<script type="text/javascript" src="scripts/Detector.js"></script>

<script type = "text/javascript" src="scripts/stats.js/build/stats.min.js"></script>
<script type="text/javascript" src="scripts/dat.gui.min.js"></script>

<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="simulator.js"></script>


<head>
    <title>Openpixi</title>
</head>
<body>
<!--begin shaders-->

<!-- pass through shaders -->
<script id="passThruVertexShader" type="x-shader/x-vertex">

			void main()	{

				gl_Position = vec4( position, 1.0 );

			}

		</script>

<script id="passThruFragmentShader" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;

				vec3 color = texture2D( texture, uv ).xyz;

				gl_FragColor=vec4(color, 1.0);

			}

		</script>
<!-- end pass through shaders -->

<!--particle acceleration, position and velocity shaders -->
<script id="fragmentShaderPosition" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D texturePosition;

            const float UPPER_BOUNDS = 200.0;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			void main()	{


				vec2 uv = gl_FragCoord.xy / resolution.xy;

				vec3 position = texture2D( texturePosition, uv ).xyz;

				vec3 velocity = texture2D( textureVelocity, uv ).xyz;

				//periodic boundary box:
				if ((position.x + velocity.x ) < LOWER_BOUNDS) position.x += UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) < LOWER_BOUNDS) position.y += UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) < LOWER_BOUNDS) position.z += UPPER_BOUNDS*2.0;

				if ((position.x + velocity.x ) > UPPER_BOUNDS) position.x -= UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) > UPPER_BOUNDS) position.y -= UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) > UPPER_BOUNDS) position.z -= UPPER_BOUNDS*2.0;

				gl_FragColor=vec4(position + velocity*dt , 1.0);

			}

		</script>


<script id="fragmentShaderVelocity" type="x-shader/x-fragment">

			uniform vec2 resolution;
			uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D texturePosition;
			uniform sampler2D textureAcceleration;

			const float UPPER_BOUNDS = 200.0;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			const float bouncy = 1.0;


			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;



				vec3 oldPosition = texture2D( texturePosition, uv ).xyz;
				vec3 oldVelocity = texture2D( textureVelocity, uv ).xyz;
				vec3 acceleration = texture2D( textureAcceleration, uv).xyz;


				vec3 velocity=oldVelocity+acceleration*dt;

                //bounding box
                //wall
                // if ((oldPosition.x + velocity.x ) < LOWER_BOUNDS) velocity.x = -velocity.x*bouncy;
				//if ((oldPosition.y + velocity.y ) < LOWER_BOUNDS) velocity.y = -velocity.y*bouncy;
				//if ((oldPosition.z + velocity.z ) < LOWER_BOUNDS) velocity.z = -velocity.z*bouncy;

				//if ((oldPosition.x + velocity.x ) > UPPER_BOUNDS) velocity.x = -velocity.x*bouncy;
				//if ((oldPosition.y + velocity.y ) > UPPER_BOUNDS) velocity.y = -velocity.y*bouncy;
				//if ((oldPosition.z + velocity.z ) > UPPER_BOUNDS) velocity.z = -velocity.z*bouncy;

                //periodic
                //do not change velocity


				gl_FragColor=vec4(velocity, 1.0);

			}

		</script>

<script id="fragmentShaderAcceleration" type="x-shader/x-fragment">



            uniform vec2 resolution;
            uniform float dt;
			uniform sampler2D textureVelocity;
			uniform sampler2D textureMQ;
            float gy;

            uniform float size;

            uniform sampler2D textureFieldB;
            uniform sampler2D textureFieldE;
            uniform sampler2D texturePosition;

            uniform sampler2D textureField;

            const float drag = 0.0005;

            vec2 getFieldPoint(vec3 pos){


                float maxval = 400.0;


                //map particles position  to [0,size]
                float x = ((pos.x+maxval/2.0)/maxval)*(size);
                float y = ((pos.y+maxval/2.0)/maxval)*(size);
                float z = ((pos.z+maxval/2.0)/maxval)*(size);

                //now round to nearest fp
                float lx = floor(x);
                float ly = floor(y);
                float lz = floor(z);


                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);


                float qu = col*(size)+lx;
                float qv = row*(size)+ly;



                qu = (qu+0.5)/(size*width);
                qv = (qv+0.5)/(size*width);


                return vec2(qu,qv);


            }

            void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;


                vec3 pos = texture2D(texturePosition,uv).xyz;

                vec2 quv = getFieldPoint(pos);


                vec3 B = texture2D(textureFieldB,quv).xyz;
                vec3 E = texture2D(textureFieldE,quv).xyz;

                float q = texture2D(textureMQ,uv).y;
                float m = texture2D(textureMQ,uv).x;

                vec3 v = texture2D(textureVelocity,uv).xyz;
                vec3 acceleration =  -drag * v + m*gy + (q/m*(E+cross(v,B)));


				gl_FragColor=vec4(acceleration,1.0);


				}



</script>

<script id="fragmentShaderFieldE" type="x-shader/x-fragment">
           uniform sampler2D textureFieldE;
           uniform sampler2D textureFieldB;
           uniform sampler2D textureFieldJ;
           uniform float dt;
           uniform float size;
           uniform vec2 resolution;


            float width = ceil(sqrt(size));

            vec4 getSteps(vec2 uv,float h){

                //calculate new uv vector if x changes by +h

                float x = uv.x*(size*width);
                float col = floor(uv.x*width);
                float localx = x-col*size;
                localx = mod((localx+size+h),size);
                x=col*size+localx;

                x = x/(size*width);


                //calculate new uv vector if y changes by +h

                float y = uv.y*(size*width);
                float row = floor(uv.y*width);
                float localy = y-row*size;
                localy = mod((localy+size+h),size);
                y = row*size+localy;

                y = y/(size*width);

                //calculate new uv vector if z changes by +h

                vec2 zuv=uv;
                float posz = col+row*width;
                posz=mod((posz+size+h),size); //tile number + h

                float tx = uv.x*(size*width);
                float ty = uv.y*(size*width);

                //per tile coordinate
                localx = tx - col*size;

                localy = ty - row*size;

                //new col and row
                col = mod(posz,width);
                row = floor(posz/width);

                zuv.x = col * size + localx;
                zuv.x = (zuv.x)/(size*width);

                zuv.y = row * size + localy;
                zuv.y = (zuv.y)/(size*width);

                return vec4(x,y,zuv);

            }


           vec3 rotorNeg(vec2 uv){

            float h = 1.0;

            vec4 vecuv = getSteps(uv,-h);//vec2(9.0/15.0,9.0/15.0),-h);

            vec3 bold = texture2D(textureFieldB,uv).xyz;

            vec3 dx = texture2D(textureFieldB, vec2(vecuv.x,uv.y)).xyz;
            vec3 dy = texture2D(textureFieldB, vec2(uv.x,vecuv.y)).xyz;
            vec3 dz = texture2D(textureFieldB, vec2(vecuv.z,vecuv.w)).xyz;

            //float rxl = (dy.z-bold.z)/h;
            //float rxr = (dz.y-bold.y)/h;

            //float ryl = (dz.x-bold.x)/h;
            //float ryr = (dx.z-bold.z)/h;

            //float rzl = (dx.y-bold.y)/h;
            //float rzr = (dy.x-bold.x)/h;

            float rxl = (bold.z-dy.z)/h;
            float rxr = (bold.y-dz.y)/h;

            float ryl = (bold.x-dz.x)/h;
            float ryr = (bold.z-dx.z)/h;

            float rzl = (bold.y-dx.y)/h;
            float rzr = (bold.x-dy.x)/h;


            float rx = rxl-rxr;
            float ry = ryl-ryr;
            float rz = rzl-rzr;

            //if(abs(rx)>0.1||abs(ry)>1.0||abs(rz)>0.1){
            //return vec3(0.0,0.0,0.0);
            //}

            //if(vecuv.w == 9.0){
            //return vec3(0.0,0.0,0.0);
            //}

            return vec3(rx,ry,rz);


            }


           void main(){

            vec2 uv = vec2(gl_FragCoord.x/(size*width),gl_FragCoord.y/(size*width));


            vec3 rotB = rotorNeg(uv);
            vec3 j = texture2D(textureFieldJ,uv).xyz;
            vec3 E_old = texture2D(textureFieldE,uv).xyz;
            vec3 E_new = E_old + dt*(rotB);//-j);



            gl_FragColor=vec4(E_new, 1.0);//rotB


           }
</script>

<script id="fragmentShaderFieldB" type="x-shader/x-fragment">

           uniform sampler2D textureFieldE;
           uniform sampler2D textureFieldB;
           uniform float dt;
           uniform float size;
           uniform vec2 resolution;




            float width = ceil(sqrt(size));


            vec4 getSteps(vec2 uv,float h){

                //calculate new uv vector if x changes by +h

                float x = uv.x*(size*width);
                float col = floor(uv.x*width);
                float localx = x-col*size;
                localx = mod((localx+h),size);
                x=col*size+localx;

                x = x/(size*width);


                //calculate new uv vector if y changes by +h

                float y = uv.y*(size*width);
                float row = floor(uv.y*width);
                float localy = y-row*size;
                localy = mod((localy+h),size);
                y = row*size+localy;

                y = y/(size*width);


                //calculate new uv vector if z changes by +h

                vec2 zuv=uv;
                float posz = col+row*width;
                posz=mod((posz+h),size); //tile number + h

                float tx = uv.x*(size*width);
                float ty = uv.y*(size*width);

                //per tile coordinate
                localx = tx - col*size;

                localy = ty - row*size;

                //new col and row
                col = mod(posz,width);
                row = floor(posz/width);

                zuv.x = col * size + localx;
                zuv.x = (zuv.x)/(size*width);

                zuv.y = row * size + localy;
                zuv.y = (zuv.y)/(size*width);

                return vec4(x,y,zuv.x, zuv.y);


            }

            vec3 rotor(vec2 uv){

            float h =1.0;
            vec4 vecuv = getSteps(uv,h);


            vec3 eold = texture2D(textureFieldE, uv).xyz;
            vec3 dx = texture2D(textureFieldE, vec2(vecuv.x,uv.y)).xyz;
            vec3 dy = texture2D(textureFieldE, vec2(uv.x,vecuv.y)).xyz;
            vec3 dz = texture2D(textureFieldE, vec2(vecuv.z,vecuv.w)).xyz;

            float rxl = (dy.z-eold.z)/h;
            float rxr = (dz.y-eold.y)/h;

            float ryl = (dz.x-eold.x)/h;
            float ryr = (dx.z-eold.z)/h;

            float rzl = (dx.y-eold.y)/h;
            float rzr = (dy.x-eold.x)/h;



            float rx = rxl-rxr;
            float ry = ryl-ryr;
            float rz = rzl-rzr;

            //if(abs(rx)>0.1||abs(ry)>1.0||abs(rz)>0.1){
            //return vec3(0.0,0.0,0.0);
            //}

            //if(dy.x==0.2){//&&abs(uv.y-2.5/15.0)<0.01){
            //return vec3(-10.0,0.5,0.0);
            //}

            return vec3(rx,ry,rz);

          }


           void main(){

            vec2 uv = vec2(gl_FragCoord.x/(size*width),gl_FragCoord.y/(size*width));

            vec3 rotE = rotor(uv);
            vec3 B_old = texture2D(textureFieldB,uv).xyz;
            vec3 B_new = B_old - dt*rotE;

            gl_FragColor=vec4(B_new, 1.0);


           }

</script>

<script id="fragmentShaderJ" type="x-shader/x-fragment">
    //todo: j null setzen nachdem hinzuaddiet bei e shader

    uniform vec2 resolution;
    uniform float size;
    uniform float dt;
    uniform int init;

    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    uniform sampler2D textureJ;


            vec2 getFieldPoint(vec3 pos){


                float maxval = 400.0;


                //map particles position  to [0,size]
                float x = ((pos.x+maxval/2.0)/maxval)*(size);
                float y = ((pos.y+maxval/2.0)/maxval)*(size);
                float z = ((pos.z+maxval/2.0)/maxval)*(size);

                //now round to nearest fp
                float lx = floor(x);
                float ly = floor(y);
                float lz = floor(z);


                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);


                float qu = col*(size)+lx;
                float qv = row*(size)+ly;



                qu = (qu+0.5)/(size*width);
                qv = (qv+0.5)/(size*width);


                return vec2(qu,qv);


            }


        void main(){
        float LOWER_BOUNDS = -200.0;
        float UPPER_BOUNDS = 200.0;
        vec2 uv = gl_FragCoord.xy/resolution.xy;
        vec3 j = texture2D(textureJ,uv).xyz;


        for(int x = 0; x<100;x++){

            for(int y = 0; y<100;y++){

                vec2 look = vec2((float(x)+0.5)/100.0,(float(y)+0.5)/100.0);
                vec3 position = texture2D(texturePosition,look).xyz;
                vec3 velocity = texture2D(textureVelocity,look).xyz;


                //previous position
                if ((position.x - velocity.x ) < LOWER_BOUNDS) position.x += UPPER_BOUNDS*2.0;
				if ((position.y - velocity.y ) < LOWER_BOUNDS) position.y += UPPER_BOUNDS*2.0;
				if ((position.z - velocity.z ) < LOWER_BOUNDS) position.z += UPPER_BOUNDS*2.0;

				if ((position.x - velocity.x ) > UPPER_BOUNDS) position.x -= UPPER_BOUNDS*2.0;
				if ((position.y - velocity.y ) > UPPER_BOUNDS) position.y -= UPPER_BOUNDS*2.0;
				if ((position.z - velocity.z ) > UPPER_BOUNDS) position.z -= UPPER_BOUNDS*2.0;

				vec2 fp1 = getFieldPoint(position-velocity*dt);



                //current position
                vec2 fp2 = getFieldPoint(position);



                //next position
                if ((position.x + velocity.x ) < LOWER_BOUNDS) position.x += UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) < LOWER_BOUNDS) position.y += UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) < LOWER_BOUNDS) position.z += UPPER_BOUNDS*2.0;

				if ((position.x + velocity.x ) > UPPER_BOUNDS) position.x -= UPPER_BOUNDS*2.0;
				if ((position.y + velocity.y ) > UPPER_BOUNDS) position.y -= UPPER_BOUNDS*2.0;
				if ((position.z + velocity.z ) > UPPER_BOUNDS) position.z -= UPPER_BOUNDS*2.0;

                vec2 fp3 = getFieldPoint(position+velocity*dt);


                if(abs(fp2.x-uv.x)<=0.001&&abs(fp2.y-uv.y)<=0.0001){//particle belongs to current field point
                j=vec3(0.0,0.01,0.0);
                //case1: particle was in another fieldpoint before
                //if(fp1.x!=fp2.x&&fp1.x!=fp2.x){
                //j+=vec3(0.0,0.01,0.0);
                //}

                //case2: particle will belong to another fieldpoint
                //if(fp3.x!=fp2.x&&fp2.x!=fp3.x){
                //j-=vec3(0.0,0.01,0.0);

                //}

                //case3: particle stays with fieldpoint, nothing happens
                //if(init==1){//todo:

                //j+=vec3(0.0,0.01,0.0);


                //}


                }




            }

        }



        gl_FragColor=vec4(j,1.0);


    }


</script>



<!-- end  position and velocity shaders -->

<!--particle shaders-->

<script id="particleVertexShader" type="x-shader/x-fragment">

     uniform sampler2D lookup;
     uniform float size;
     uniform float scale;

        void main() {

            vec2 lookupuv = position.xy ;
            vec3 pos = texture2D( lookup, lookupuv ).rgb;
            vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
            gl_PointSize  = 1.5;
            gl_Position = projectionMatrix * mvPosition;

}

</script>


<script id="particleFragmentShader" type="x-shader/x-fragment">

                uniform vec3 psColor;
                uniform float opacity;
                void main() {



                gl_FragColor = vec4( 1.0,1.0,1.0, opacity );
                }
</script>

<!--end particle shaders-->

<!--begin E,B vector shaders-->

<script id="vectorVertexShaderE" type="x-shader/x-vertex">
uniform sampler2D textureFieldE;
uniform float size;
uniform float width;
uniform float test;

vec2 getUV(vec3 pos){


                float maxval = 400.0;


                //map particles position  to [0,size]
                float x = ((pos.x+maxval/2.0)/maxval)*(size);
                float y = ((pos.y+maxval/2.0)/maxval)*(size);
                float z = ((pos.z+maxval/2.0)/maxval)*(size);

                //now round to nearest fp
                float lx = floor(x);
                float ly = floor(y);
                float lz = floor(z);


                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);


                float qu = col*(size)+lx;
                float qv = row*(size)+ly;



                qu = (qu+0.5)/(size*width);
                qv = (qv+0.5)/(size*width);


                return vec2(qu,qv);


            }

void main() {


vec4 mvPosition;

    mvPosition = modelViewMatrix * vec4( position, 1.0 );


    if(position.y>200.0){
        vec2 uv = getUV(vec3(position.x,position.y-1000.0,position.z));
        vec3 E = texture2D(textureFieldE,uv).xyz;
        vec3 pos = vec3(position.x,position.y-1000.0,position.z);
        pos = pos +E*200.0;//200 is visibility factor
        mvPosition = modelViewMatrix * vec4(pos,1.0);
    }

    gl_Position = projectionMatrix * mvPosition;



}

</script>

<script id="vectorVertexShaderB" type="x-shader/x-vertex">

uniform sampler2D textureFieldB;
uniform float size;
uniform float width;


vec2 getUV(vec3 pos){


                float maxval = 400.0;


                //map particles position  to [0,size]
                float x = ((pos.x+maxval/2.0)/maxval)*(size);
                float y = ((pos.y+maxval/2.0)/maxval)*(size);
                float z = ((pos.z+maxval/2.0)/maxval)*(size);

                //now round to nearest fp
                float lx = floor(x);
                float ly = floor(y);
                float lz = floor(z);


                float width = ceil(sqrt(size));


                float row = floor(lz/width);
                float col = mod(lz,width);


                float qu = col*(size)+lx;
                float qv = row*(size)+ly;



                qu = (qu+0.5)/(size*width);
                qv = (qv+0.5)/(size*width);


                return vec2(qu,qv);


            }

void main() {


    vec4 mvPosition;

    mvPosition = modelViewMatrix * vec4( position, 1.0 );


    if(position.y>200.0){
        vec2 uv = getUV(vec3(position.x,position.y-1000.0,position.z));

        vec3 B = texture2D(textureFieldB,uv).xyz;
        vec3 pos = vec3(position.x,position.y-1000.0,position.z);
        pos = pos +B*200.0;//200 is visibility factor

        mvPosition = modelViewMatrix * vec4(pos,1.0);
    }

    gl_Position = projectionMatrix * mvPosition;



}

</script>

<script id="vectorFragmentShaderE" type="x-shader/x-fragment">

vec3 vColor = vec3(1.0,0.0,1.0);



void main() {

gl_FragColor =  vec4( vColor, 1.0 );


}
</script>

<script id="vectorFragmentShaderB" type="x-shader/x-fragment">

vec3 vColor = vec3(1.0,1.0,0.0);



void main() {

gl_FragColor =  vec4( vColor, 1.0 );


}
</script>
<!--end E,B vector shaders-->

<!--end shaders-->

<!-- global variables -->

<script type="text/javascript">

    //check if WebGL is supported
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();


    //texture debug
    var cameraTex, sceneTex;
    var dispTex = false;
    sceneTex = new THREE.Scene();
    cameraTex = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );

    //global variables
    var WIDTH = 100; // sqrt(number of particles)
    var BOUNDS = 400; //Particle coordinates range from -bounds/2 to bounds/2
    var DT = 1; //delta time
    var FSIZE;
    var B;
    var E;

    var FXY,FZ;

    var container, camera, scene, renderer; //main scene

    var particles, material, geometry; //the particle system

    var uniforms; //uniforms for the particle system's shader

    var simul; //the simulator updates the particles' positions


    //three.js
    container = document.createElement( 'div' );
    document.body.appendChild( container );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 150000 );
    camera.position.z = 400;

    //controls
    var controls = new THREE.OrbitControls( camera, renderer.domElement );


    //gui
    var text;

    var guitext = function(){
        this.gy = 0.0;
        this.Particles = 1;
        this.dt = 0.01;
        this.fieldpoints =5;

        this.Bx = 0.0;
        this.By = 0.0;
        this.Bz = 0.0;

        this.Ex = 0.0;
        this.Ey = 0.0;
        this.Ez = 0.0;

        this.m = 0.000;
        this.q = 0.0;


    }


    text = new guitext();
    var gui = new dat.GUI({autoPlace: true});
    var f1 = gui.addFolder('B');
    var f2 = gui.addFolder('E');



    gui.add(text, 'Particles',1,10000);
    gui.add(text,'dt',0.0,10.0);
    gui.add(text,'fieldpoints',2,20).step(1);
    gui.add(text, 'gy',-0.9999,0.9999);

    gui.add(text,'m',0.0,1.0);
    gui.add(text,'q',-1.0,1.0);

    f1.add(text,'Bx',-0.1,0.1);
    f1.add(text,'By',-0.1,0.1);
    f1.add(text,'Bz',-0.1,0.1);

    f2.add(text,'Ex',-0.1,0.1);
    f2.add(text,'Ey',-0.1,0.1);
    f2.add(text,'Ez',-0.1,0.1);




    var obj = {reset: function(){init()}};
    gui.add(obj,'reset');

    var inf = {info: function(){//FIXME
        alert('left-click to move camera, \nhold mousewheel to zoom,\n click reset to apply changes')}};

    gui.add(inf,'info');

    var debug= {debug: function(){
        dispTex = !dispTex;
    }}
    gui.add(debug,'debug');


    //end gui

    //stats

    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    document.body.appendChild( stats.domElement );

    //end stats



    //start simulation

    init();




</script>

</body>

</html>